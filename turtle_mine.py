import math
import matplotlib.pyplot as plt

class TurtleInterpreter:
    """
    Class to interpret turtle graphics using a given set of rules.

    Attributes:
        rules_population (list): Population of strings representing rules.
        angle_increment (float): Incremental angle for turning.
        x (float): Current x-coordinate of the turtle.
        y (float): Current y-coordinate of the turtle.
        alpha (float): Current orientation of the turtle (in degrees).
        step_size (float): Step size for moving forward/backward.
        stack (list): Stack to manage states for branching.
        Path_Array (list): Array to store paths generated by interpreting strings.
    """

    def __init__(self, rules_population, angle_increment, x0=0, y0=0, alpha=90, step_size=1):
        """
        Initialize the TurtleInterpreter.

        Args:
            rules_population (list): Population of strings representing rules.
            angle_increment (float): Incremental angle for turning.
            x0 (float): Initial x-coordinate of the turtle.
            y0 (float): Initial y-coordinate of the turtle.
            alpha (float): Initial orientation of the turtle (in degrees).
            step_size (float): Step size for moving forward/backward.
        """
        self.rules_population = rules_population
        self.x = x0
        self.y = y0
        self.alpha = alpha
        self.step_size = step_size
        self.angle_increment = angle_increment
        self.stack = []
        self.Path_Array = []  # Array to store paths

    def move_forward(self, draw=False):
        """
        Move the turtle forward.

        Args:
            draw (bool): Flag indicating whether to draw the movement on a plot.
        """
        x_new = self.x + self.step_size * math.cos(math.radians(self.alpha))
        y_new = self.y + self.step_size * math.sin(math.radians(self.alpha))
        if draw:
            plt.plot([self.x, x_new], [self.y, y_new], 'k-')
        self.x, self.y = round(x_new, 2), round(y_new, 2)

    def move_backward(self, draw=False):
        """
        Move the turtle backward.

        Args:
            draw (bool): Flag indicating whether to draw the movement on a plot.
        """
        x_new = self.x - self.step_size * math.cos(math.radians(self.alpha))  # Adjusted for moving backward
        y_new = self.y - self.step_size * math.sin(math.radians(self.alpha))  # Adjusted for moving backward
        if draw:
            plt.plot([self.x, x_new], [self.y, y_new], 'k-')
        self.x, self.y = round(x_new, 2), round(y_new, 2)

    def turn_left(self):
        """Turn the turtle left."""
        self.alpha += self.angle_increment

    def turn_right(self):
        """Turn the turtle right."""
        self.alpha -= self.angle_increment

    def push_state(self):
        """Push the current state onto the stack."""
        self.stack.append((self.x, self.y, self.alpha))

    def pop_state(self):
        """Pop the state from the stack and restore the turtle's state."""
        self.x, self.y, self.alpha = self.stack.pop()

    def interpret_string(self):
        """Interpret the strings in the rules population and generate paths."""
        for string in self.rules_population:
            self.reset()  # Reset turtle to initial state
            path = [(self.x, self.y, self.alpha)]  # Initialize path for the current string
            for char in string:
                if char == 'F':
                    self.move_forward()
                    path.append((self.x, self.y, self.alpha))  # Append current position to path
                elif char == 'f':
                    self.move_forward(draw=False)
                elif char == '+':
                    self.turn_left()
                elif char == '-':
                    self.turn_right()
                elif char == '[':
                    self.push_state()
                elif char == ']':
                    self.pop_state()
                    path.append((self.x, self.y, self.alpha))  # Append current position to path
            self.Path_Array.append(path)  # Append the path for the current string to the array

    def reset(self, x0=0, y0=0, alpha=90):
        """
        Reset the turtle to its initial state.

        Args:
            x0 (float): Initial x-coordinate of the turtle.
            y0 (float): Initial y-coordinate of the turtle.
            alpha (float): Initial orientation of the turtle (in degrees).
        """
        self.x = x0
        self.y = y0
        self.alpha = alpha
        self.stack = []

    def calculate_rewards(self, count):
        """
        Calculate rewards based on a count.

        Args:
            count (int): Count to calculate rewards for.

        Returns:
            list: List of rewards.
        """
        return [i / count for i in range(1, count + 1)]
    
    def clear_paths(self):
        """Clear the Path_Array."""
        self.Path_Array = []